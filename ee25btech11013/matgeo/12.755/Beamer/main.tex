\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usetheme{Madrid}
\usecolortheme{default}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathtools}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{tfrupee}
\usepackage{array}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\lstset{literate={·}{{$\cdot$}}1 {λ}{{$\lambda$}}1 {→}{{$\to$}}1}
\usepackage{graphicx}

\setbeamertemplate{page number in head/foot}[totalframenumber]

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}

\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3,
}
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
}

\title{12.755}
\date{October 10, 2025}
\author{Bhargav - EE25BTECH11013}

\begin{document}

\frame{\titlepage}

\begin{frame}{Question}
\textbf{Question}: \\
Which one of the following vectors is an eigenvector corresponding to the eigenvalue $\lambda = 1$ for the matrix $\vec{A} = \myvec{1 & -1 & 0 \\  1 & -1 & 1 \\ -1 & 0 & 1}$ is
\end{frame}

\begin{frame}{Solution}
The eigenvector $\vec{x}$ of matrix $\vec{A}$ corresponding to an eigenvalue $\lambda$ can be found using the relation:
\begin{align}
\vec{A}\vec{x} = \lambda \vec{x} \implies \brak{\vec{A}-\lambda\vec{I}}\vec{x} = \vec{0}
\end{align}
For the given eigenvalue $\lambda = 1$:
\begin{align}
\brak{\vec{A}-\vec{I}}\vec{x} = \vec{0}
\end{align}
\begin{align}
\implies \myvec{0 & -1 & 0 \\ 1 & -2 & 1 \\ -1 & 0 & 0}\vec{x} = \vec{0}
\end{align}
\end{frame}

\begin{frame}{Solution}
This can be solved by representing it as an augmented matrix and using row elimination:
\begin{align}
\augvec{3}{1}{0 & -1 & 0 & 0 \\ 1 & -2 & 1 & 0 \\ -1 & 0 & 0 & 0} \xleftrightarrow{R_1 \leftarrow R_1 + R_2} \augvec{3}{1}{1 & -3 & 1 & 0 \\ 1 & -2 & 1 & 0 \\ -1 & 0 & 0 & 0}
\end{align}
\begin{align}
\xleftrightarrow[R_3 \leftarrow R_3 + R_1]{R_2 \leftarrow R_2 - R_1} \augvec{3}{1}{1 & -3 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & -3 & 1 & 0}
\end{align}
\begin{align}
\xleftrightarrow[R_3 \leftarrow R_3 + 3R_2]{R_1 \leftarrow R_1 + 3R_2}\augvec{3}{1}{1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0}
\end{align}
Thus we get the trivial solution $\vec{x} = \myvec{0 \\ 0 \\ 0}$.
\end{frame}

\begin{frame}{Solution}
This can be further verified by finding the intersection of the planes defined by the system of equations:
\begin{align}
-y &= 0 \\
x-2y+z&=0 \\
-x &= 0
\end{align}
The only intersection point is the origin $\myvec{0 \\ 0 \\ 0}$.
\end{frame}
\begin{frame}{Plot}
    \begin{figure}[H]
        \centering
        \includegraphics[height=0.5\textheight, keepaspectratio]{figs/Figure_1.png}
    \end{figure}
\end{frame}
\begin{frame}[fragile]
    \frametitle{C Code}
    \begin{lstlisting}
#include <stdio.h>
#include <math.h>

#define N 3

// Function to print a matrix
void print_matrix(double A[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%8.3f ", A[i][j]);
        }
        printf("\n");
    }
}

// Function to compute B = A - λI
void subtract_lambda_identity(double A[N][N], double B[N][N], double lambda) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i == j)
                B[i][j] = A[i][j] - lambda;
            else
                B[i][j] = A[i][j];
        }
    }
}

// Function to check if λ = 1 is approximately an eigenvalue (det ~ 0)
double determinant(double A[N][N]) {
    double det =
        A[0][0]*(A[1][1]*A[2][2] - A[1][2]*A[2][1]) -
        A[0][1]*(A[1][0]*A[2][2] - A[1][2]*A[2][0]) +
        A[0][2]*(A[1][0]*A[2][1] - A[1][1]*A[2][0]);
    return det;
}

// Exposed function to be called from Python
void process_matrix(double A[N][N], double B[N][N], double lambda) {
    printf("Matrix A:\n");
    print_matrix(A);
    printf("\n---------------------------------\n");

    double detA = determinant(A);
    printf("Determinant of A = %.3f\n", detA);

    subtract_lambda_identity(A, B, lambda);
    printf("\nMatrix (A - %.2fI):\n", lambda);
    print_matrix(B);

    double detB = determinant(B);
    printf("\nDeterminant of (A - %.2fI) = %.3f\n", lambda, detB);
    if (fabs(detB) > 1e-6)
        printf("\nλ = %.2f is NOT an eigenvalue of A.\n", lambda);
    else
        printf("\nλ = %.2f is an eigenvalue of A.\n", lambda);
}


    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{C Code}
    \begin{lstlisting}
void subtract_lambda_identity(double A[N][N], double B[N][N], double lambda) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (i == j)
                B[i][j] = A[i][j] - lambda;
            else
                B[i][j] = A[i][j];
        }
    }
}

// Function to check if λ = 1 is approximately an eigenvalue (det ~ 0)
double determinant(double A[N][N]) {
    double det =
        A[0][0]*(A[1][1]*A[2][2] - A[1][2]*A[2][1]) -
        A[0][1]*(A[1][0]*A[2][2] - A[1][2]*A[2][0]) +
        A[0][2]*(A[1][0]*A[2][1] - A[1][1]*A[2][0]);
    return det;
}

// Exposed function to be called from Python
void process_matrix(double A[N][N], double B[N][N], double lambda) {
    printf("Matrix A:\n");
    print_matrix(A);
    printf("\n---------------------------------\n");

    double detA = determinant(A);
    printf("Determinant of A = %.3f\n", detA);

    subtract_lambda_identity(A, B, lambda);
    printf("\nMatrix (A - %.2fI):\n", lambda);
    print_matrix(B);

    double detB = determinant(B);
    printf("\nDeterminant of (A - %.2fI) = %.3f\n", lambda, detB);
    if (fabs(detB) > 1e-6)
        printf("\nλ = %.2f is NOT an eigenvalue of A.\n", lambda);
    else
        printf("\nλ = %.2f is an eigenvalue of A.\n", lambda);
}



    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python + C Code}
    \begin{lstlisting}
import numpy as np, ctypes, matplotlib.pyplot as plt
from matplotlib.lines import Line2D

lib = ctypes.CDLL("./libeig.so")
lib.process_matrix.argtypes = [
    np.ctypeslib.ndpointer(dtype=np.double, ndim=2, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.double, ndim=2, flags="C_CONTIGUOUS"),
    ctypes.c_double
]; lib.process_matrix.restype = None

A = np.array([[1,-1,0],[1,-1,1],[-1,0,1]],dtype=np.double)
B = np.zeros((3,3),dtype=np.double)
lib.process_matrix(A,B,1.0)



    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python + C Code}
    \begin{lstlisting}
print("\nEigenvalues of A:", np.real_if_close(np.linalg.eigvals(A)))

fig = plt.figure(); ax = fig.add_subplot(111, projection='3d')
d = np.linspace(-2,2,30)
ax.plot_surface(*np.meshgrid(d,d), 0*np.meshgrid(d,d)[0], alpha=0.5,color='r')
ax.plot_surface(*np.meshgrid(d,d), -np.meshgrid(d,d)[0]+2*np.meshgrid(d,d)[1], alpha=0.5,color='g')
ax.plot_surface(0*np.meshgrid(d,d)[0], *np.meshgrid(d,d), alpha=0.5,color='b')
ax.scatter(0,0,0,color='k',s=50)

# Legend using Line2D proxies
ax.legend(handles=[Line2D([0],[0], color='r', lw=4, alpha=0.5, label='-y=0'),
                   Line2D([0],[0], color='g', lw=4, alpha=0.5, label='x-2y+z=0'),
                   Line2D([0],[0], color='b', lw=4, alpha=0.5, label='-x=0')])




    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python + C Code}
    \begin{lstlisting}
ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')
ax.set_title('Intersection of Planes for (A-I)x=0')
ax.view_init(20,-65)
plt.savefig("/mnt/c/Users/bharg/Documents/backupmatrix/ee25btech11013/matgeo/12.755/figs/Figure_1.png")
plt.show()
    \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
    \frametitle{Python Code}
    \begin{lstlisting}
import numpy as np
import matplotlib.pyplot as plt

# Define vectors and point
u1 = np.array([1.0, 1.0, 0.0])
u2 = np.array([0.0, 1.0, 1.0])
P  = np.array([1.0, 1.0, 1.0])

# Stack u1 and u2 as columns to form U
U = np.column_stack((u1, u2))

# Compute projection coefficients: inv(U^T U) * U^T * P
coeff = np.linalg.inv(U.T @ U) @ (U.T @ P)

# Compute projection point
P_proj = U @ coeff


    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python Code}
    \begin{lstlisting}
import numpy as np
import matplotlib.pyplot as plt

A = np.array([
    [1, -1, 0],
    [1, -1, 1],
    [-1, 0, 1]
])

print("Matrix A:\n", A, "\n" + "-"*30)

eigenvalues, _ = np.linalg.eig(A)

print("Actual Eigenvalues of A:\n", np.real_if_close(eigenvalues))
print("\nNote: 1 is not an eigenvalue of matrix A.")
print("This indicates an error in the problem statement.", "\n" + "-"*30)

lambda_val = 1
B = A - lambda_val * np.identity(A.shape[0])

print(f"Matrix for (A - {lambda_val}I)x = 0:\n", B)
print("\nCorresponding system of linear equations:")
print(f"  -y = 0")
print(f"  x - 2y + z = 0")
print(f"  -x = 0")
print("\nThe only solution is (0,0,0), so no non-zero eigenvector exists.", "\n" + "-"*30)

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

d = np.linspace(-2, 2, 30)

# Plane 1: -y = 0
X1, Z1 = np.meshgrid(d, d)
Y1 = np.zeros_like(X1)
surf1 = ax.plot_surface(X1, Y1, Z1, alpha=0.5, color='r')
surf1._facecolors2d = surf1._facecolor3d
surf1._edgecolors2d = surf1._edgecolor3d


    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python Code}
    \begin{lstlisting}
# Plane 2: x - 2y + z = 0
X2, Y2 = np.meshgrid(d, d)
Z2 = -X2 + 2*Y2
surf2 = ax.plot_surface(X2, Y2, Z2, alpha=0.5, color='g')
surf2._facecolors2d = surf2._facecolor3d
surf2._edgecolors2d = surf2._edgecolor3d





    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python Code}
    \begin{lstlisting}
# Plane 3: -x = 0
Y3, Z3 = np.meshgrid(d, d)
X3 = np.zeros_like(Y3)
surf3 = ax.plot_surface(X3, Y3, Z3, alpha=0.5, color='b')
surf3._facecolors2d = surf3._facecolor3d
surf3._edgecolors2d = surf3._edgecolor3d

ax.scatter([0], [0], [0], color='black', s=100, label='Intersection (0,0,0)')

ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')
ax.set_title('Intersection of Planes for (A-I)x = 0')

ax.legend([surf1, surf2, surf3], ['-y = 0', 'x - 2y + z = 0', '-x = 0'])

ax.view_init(elev=20, azim=-65)
plt.savefig("/mnt/c/Users/bharg/Documents/backupmatrix/ee25btech11013/matgeo/12.755/figs/Figure_1.png")
plt.show()


    \end{lstlisting}
\end{frame}

\end{document}


\end{document}
