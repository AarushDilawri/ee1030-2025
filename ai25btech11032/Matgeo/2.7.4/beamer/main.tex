\documentclass{beamer}
\mode<presentation>
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{advdate}
\usepackage{adjustbox}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\def\UrlBreaks{\do\/\do-}
\usetheme{Boadilla}
\usecolortheme{lily}
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=\paperwidth,ht=2.25ex,dp=1ex,right]{author in head/foot}%
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\setbeamertemplate{navigation symbols}{}

\providecommand{\nCr}[2]{\,^{#1}C_{#2}} % nCr
\providecommand{\nPr}[2]{\,^{#1}P_{#2}} % nPr
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
%\newcommand{\solution}{\noindent \textbf{Solution: }}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\let\vec\mathbf

\lstset{
language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}

\numberwithin{equation}{section}

\title{Presentation - Matgeo}
\author{Aryansingh Sonaye \\
AI25BTECH11032 \\
EE1030 - Matrix Theory}

\date{\today} 
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\section{Problem}
\begin{frame}
\frametitle{Problem Statement}
If
\begin{align}
\vec a = \myvec{2 \\1 \\3},\qquad
\vec b = \myvec{-1 \\2 \\1},\qquad
\vec c = \myvec{3 \\1 \\2},
\end{align}

find $\vec a\cdot(\vec b\times\vec c)$.
\end{frame}

\section{Solution}
\subsection{Description of Variables used}
\begin{frame}
\frametitle{Description of Variables used}
\begin{table}[H]
\centering
\begin{tabular}[12pt]{ |c| c|}
    \hline
    \textbf{Input variable} & \textbf{Value}\\ 
    \hline
    $\vec{a}$ & \myvec{2 \\1 \\3} \\
    \hline 
    $\vec{b}$ & \myvec{-1 \\2 \\1}\\
    \hline
    $\vec{c}$ & \myvec{3 \\1 \\2}\\
    \hline
    \end{tabular}
    \caption{}
    \label{}
 \end{table}


\end{frame}

\subsection{Theoretical Solution }
\begin{frame}
\frametitle{Theoretical Solution}
We are asked to compute:
\begin{align}
\vec{a} \cdot (\vec{b} \times \vec{c}).
\end{align}

\textbf{Step 1 — Vectors as column matrices}

\begin{align}
\vec{a} &= \myvec{2\\1\\3}, &
\vec{b} &= \myvec{-1\\2\\1}, &
\vec{c} &= \myvec{3\\1\\2}.
\end{align}

\textbf{Step 2 — Form the Gram matrix}

The Gram matrix is
\begin{align}
G &=
\myvec{
\vec{a}^T \vec{a} & \vec{a}^T \vec{b} & \vec{a}^T \vec{c} \\
\vec{b}^T \vec{a} & \vec{b}^T \vec{b} & \vec{b}^T \vec{c} \\
\vec{c}^T \vec{a} & \vec{c}^T \vec{b} & \vec{c}^T \vec{c}
}.
\end{align}
\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
Compute each entry:
\begin{align}
\vec{a}^T \vec{a} &= 14, &
\vec{b}^T \vec{b} &= 6, &
\vec{c}^T \vec{c} &= 14, \\
\vec{a}^T \vec{b} &= 3, &
\vec{b}^T \vec{c} &= 1, &
\vec{c}^T \vec{a} &= 13.
\end{align}

Thus,
\begin{align}
G = \myvec{
14 & 3 & 13 \\
3 & 6 & 1 \\
13 & 1 & 14
}.
\end{align}

\textbf{Step 3 — Gram determinant identity}

We know
\begin{align}
\det(G) &= \big(\det([\vec{a}\ \vec{b}\ \vec{c}])\big)^2 \\
        &= \big(\vec{a} \cdot (\vec{b} \times \vec{c})\big)^2.
\end{align}

\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
Direct computation gives
\begin{align}
\det(G) = 100.
\end{align}

Hence
\begin{align}
|\vec{a} \cdot (\vec{b} \times \vec{c})| &= \sqrt{100} = 10.
\end{align}

\textbf{Step 4 — Find the sign}

Form the matrix
\begin{align}
A = [\vec{a}\ \vec{b}\ \vec{c}] =
\myvec{
2 & -1 & 3 \\
1 & 2  & 1 \\
3 & 1  & 2
}.
\end{align}

Then
\begin{align}
\det(A) = \vec{a} \cdot (\vec{b} \times \vec{c}).
\end{align}


\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
Compute:
\begin{align}
\det(A) = -10.
\end{align}

\textbf{Final Answer}
\begin{align}
\boxed{\ \vec{a} \cdot (\vec{b} \times \vec{c}) = -10\ }
\end{align}


\end{frame}



\subsection{Plot}
\begin{frame}
    \frametitle{Plot}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.9\columnwidth]{figs/gram_triple_product.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}
#include <stdio.h>

// Dot product of two 3D vectors
double dot_product(double a[3], double b[3]) {
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

// Build Gram matrix from three 3D vectors
void gram_matrix(double a[3], double b[3], double c[3], double G[3][3]) {
    G[0][0] = dot_product(a,a);
    G[0][1] = dot_product(a,b);
    G[0][2] = dot_product(a,c);

    G[1][0] = dot_product(b,a);
    G[1][1] = dot_product(b,b);
    G[1][2] = dot_product(b,c);
    \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}

    G[2][0] = dot_product(c,a);
    G[2][1] = dot_product(c,b);
    G[2][2] = dot_product(c,c);
}

// Determinant of a 3x3 matrix
double det3(double M[3][3]) {
    return M[0][0]*(M[1][1]*M[2][2] - M[1][2]*M[2][1])
         - M[0][1]*(M[1][0]*M[2][2] - M[1][2]*M[2][0])
         + M[0][2]*(M[1][0]*M[2][1] - M[1][1]*M[2][0]);
}

}

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code - Python(with shared C code)}
    The code to obtain the required plot is
    \begin{lstlisting}
import ctypes
import numpy as np
import math
import matplotlib.pyplot as plt

# --- Load compiled C library ---
lib = ctypes.CDLL("./libgram.so")

# Define ctypes array types
DoubleArray3 = ctypes.c_double * 3
DoubleMatrix3 = (DoubleArray3) * 3

# Function signatures
lib.dot_product.argtypes = [DoubleArray3, DoubleArray3]
lib.dot_product.restype = ctypes.c_double

\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
lib.gram_matrix.argtypes = [DoubleArray3, DoubleArray3, DoubleArray3, DoubleMatrix3]
lib.det3.argtypes = [DoubleMatrix3]
lib.det3.restype = ctypes.c_double

# --- Define vectors ---
a = np.array([2.0, 1.0, 3.0])
b = np.array([-1.0, 2.0, 1.0])
c = np.array([3.0, 1.0, 2.0])

# Convert to C arrays
A = DoubleArray3(*a)
B = DoubleArray3(*b)
C = DoubleArray3(*c)

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
# --- Step 1: Build Gram matrix ---
G = DoubleMatrix3()
lib.gram_matrix(A, B, C, G)

# --- Step 2: Compute det(G) ---
detG = lib.det3(G)
print("det(G) =", detG)

# --- Step 3: Magnitude of scalar triple product ---
magnitude = math.sqrt(detG)
print("|a . (b x c)| =", magnitude)

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
# --- Step 4: Compute sign using det(A) ---
A_mat = np.column_stack((a, b, c))   # matrix [a b c]
sign_val = np.linalg.det(A_mat)      # NumPy to check sign
scalar_triple = math.copysign(magnitude, sign_val)
print("a . (b x c) =", scalar_triple)

# Image generation
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

def draw_vec(v, color, label):
    ax.quiver(0, 0, 0, v[0], v[1], v[2],
              color=color, arrow_length_ratio=0.1, label=label)


\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
# Draw just the vectors
draw_vec(a, 'r', 'a')
draw_vec(b, 'g', 'b')
draw_vec(c, 'b', 'c')

# Set axes limits
lim = 6
ax.set_xlim([-lim, lim])
ax.set_ylim([-lim, lim])
ax.set_zlim([-lim, lim])

# Labels
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.legend()

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
plt.title(f"Scalar triple product = {scalar_triple}")
plt.savefig("gram_triple_product.png", dpi=300)
plt.show()

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
import numpy as np
import math
import matplotlib.pyplot as plt

# --- Define vectors ---
a = np.array([2.0, 1.0, 3.0])
b = np.array([-1.0, 2.0, 1.0])
c = np.array([3.0, 1.0, 2.0])

# --- Step 1: Build Gram matrix ---
G = np.array([
    [np.dot(a, a), np.dot(a, b), np.dot(a, c)],
    [np.dot(b, a), np.dot(b, b), np.dot(b, c)],
    [np.dot(c, a), np.dot(c, b), np.dot(c, c)]
])


\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
print("Gram matrix:\n", G)

# --- Step 2: Compute det(G) ---
detG = np.linalg.det(G)
print("det(G) =", detG)

# --- Step 3: Magnitude of scalar triple product ---
magnitude = math.sqrt(detG)
print("|a . (b x c)| =", magnitude)

# --- Step 4: Compute sign using det(A) ---
A_mat = np.column_stack((a, b, c))   # matrix [a b c]
sign_val = np.linalg.det(A_mat)
scalar_triple = math.copysign(magnitude, sign_val)

print("a . (b x c) =", scalar_triple)

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
# Image Generation
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

def draw_vec(v, color, label):
    ax.quiver(0, 0, 0, v[0], v[1], v[2],
              color=color, arrow_length_ratio=0.1, label=label)

# Draw the vectors
draw_vec(a, 'r', 'a')
draw_vec(b, 'g', 'b')
draw_vec(c, 'b', 'c')

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
# Set axes limits
lim = 6
ax.set_xlim([-lim, lim])
ax.set_ylim([-lim, lim])
ax.set_zlim([-lim, lim])

# Labels
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.legend()

plt.title(f"Scalar triple product = {scalar_triple}")
plt.savefig("gram_triple_product_python.png", dpi=300)
plt.show()


\end{lstlisting}
\end{frame}

\end{document}

